%{
#include <cerrno>
#include <climits>
#include <cstdlib>
#include <string>
#include <iostream>

#include "Scanner.h"

%}

%option c++
%option yyclass="Scanner"
%option outfile="lexer.cpp"
%option noyywrap
%option stack


%x START_STRING
%x START_REGEX
%x START_QUOTEDSYMBOL

BOOL           true|false
BINARY         #b[0-1]+
HEXADECIMAL    #x[0-9a-fA-F]+
NUMERAL        0|[1-9]+[0-9]*
DECIMAL        NUMERAL\.0*NUMERAL
SYMBOL         [a-zA-Z0-9._+\-*=%?!$_~&^<>@][a-zA-Z0-9._+\-*=%/?!$_~&^<>@]+
KEYWORD        :[a-zA-Z0-9._+\-*=%?!$_~&^<>@]+

%{
  // Code run each time a pattern is matched.
  # define YY_USER_ACTION  loc.columns (yyleng);
%}

%%

%{
  // Code run each time yylex is called.
  loc.step ();
%}

";"[^\n]*\n         { loc.lines (yyleng); loc.step ();            }
\n                  { loc.lines (yyleng); loc.step ();            }
\r                  { loc.lines (yyleng); loc.step ();            }
[ \t]               { loc.step ();                                }

"("                 { return Parser::make_PAREN_O         (loc);  }
")"                 { return Parser::make_PAREN_C         (loc);  }

"!"                 { return Parser::make_BANG            (loc);  }
"_"                 { return Parser::make_UNDERSCORE      (loc);  }
"as"                { return Parser::make_AS              (loc);  }
"exists"            { return Parser::make_EXISTS          (loc);  }
"forall"            { return Parser::make_FORALL          (loc);  }
"let"               { return Parser::make_LET             (loc);  }
"par"               { return Parser::make_PAR             (loc);  }


"and"               { return Parser::make_AND             (loc);  }
"or"                { return Parser::make_OR              (loc);  }
"not"               { return Parser::make_NOT             (loc);  }
"-"                 { return Parser::make_MINUS           (loc);  }
"+"                 { return Parser::make_PLUS            (loc);  }
"="                 { return Parser::make_EQ              (loc);  }
">"                 { return Parser::make_GT              (loc);  }
">="                { return Parser::make_GE              (loc);  }
"<"                 { return Parser::make_LT              (loc);  }
"<="                { return Parser::make_LE              (loc);  }
"concat"            { return Parser::make_CONCAT          (loc);  }
"in"                { return Parser::make_IN              (loc);  }
"len"               { return Parser::make_LEN             (loc);  }
"contains"          { return Parser::make_CONTAINS        (loc);  }
"begins"            { return Parser::make_BEGINS          (loc);  }
"ends"              { return Parser::make_ENDS            (loc);  }
"indexOf"           { return Parser::make_INDEXOF         (loc);  }
"lastIndexOf"       { return Parser::make_LASTINDEXOF     (loc);  }
"charAt"            { return Parser::make_CHARAT          (loc);  }
"subString"         { return Parser::make_SUBSTRING       (loc);  }
"toUpper"           { return Parser::make_TOUPPER         (loc);  }
"toLower"           { return Parser::make_TOLOWER         (loc);  }
"trim"              { return Parser::make_TRIM            (loc);  }
"replace"           { return Parser::make_REPLACE         (loc);  }
"count"             { return Parser::make_COUNT           (loc);  }
"ite"               { return Parser::make_ITE             (loc);  }
"re.++"             { return Parser::make_RE_CONCAT       (loc);  }
"re.or"             { return Parser::make_OR              (loc);  }
"str.++"            { return Parser::make_CONCAT          (loc);  }
"str.in.re"         { return Parser::make_IN              (loc);  }
"str.len"           { return Parser::make_LEN             (loc);  }
"str.to.re"         { return Parser::make_TO_REGEX        (loc);  }

"Bool"              { return Parser::make_TBOOL           (loc);  } 
"Int"               { return Parser::make_TINT            (loc);  }
"String"            { return Parser::make_TSTRING         (loc);  }
                 
"assert"            { return Parser::make_ASSERT          (loc);  }
"check-sat"         { return Parser::make_CHECK_SAT       (loc);  }
"check-sat-and-count" { return Parser::make_CHECK_SAT_AND_COUNT  (loc);  }
"declare-fun"       { return Parser::make_DECLARE_FUN     (loc);  }
"declare-sort"      { return Parser::make_DECLARE_SORT    (loc);  }
"define-fun"        { return Parser::make_DEFINE_FUN      (loc);  }
"define-sort"       { return Parser::make_DEFINE_SORT     (loc);  }
"exit"              { return Parser::make_EXIT            (loc);  }
"get-assertions"    { return Parser::make_GET_ASSERTIONS  (loc);  }
"get-assignment"    { return Parser::make_GET_ASSIGNMENT  (loc);  }
"get-info"          { return Parser::make_GET_INFO        (loc);  }
"get-option"        { return Parser::make_GET_OPTION      (loc);  }  
"get-proof"         { return Parser::make_GET_PROOF       (loc);  }
"get-unsat-core"    { return Parser::make_GET_UNSAT_CORE  (loc);  }
"get-value"         { return Parser::make_GET_VALUE       (loc);  }
"pop"               { return Parser::make_POP             (loc);  }
"push"              { return Parser::make_PUSH            (loc);  }
"set-logic"         { return Parser::make_SET_LOGIC       (loc);  }
"set-info"          { return Parser::make_SET_INFO        (loc);  }
"set-option"        { return Parser::make_SET_OPTION      (loc);  }

{BOOL}              { return Parser::make_BOOL            (yytext, loc);  }
{BINARY}            { return Parser::make_BINARY          (yytext, loc);  }
{DECIMAL}           { return Parser::make_DECIMAL         (yytext, loc);  }
{HEXADECIMAL}       { return Parser::make_HEXADECIMAL     (yytext, loc);  }
{KEYWORD}           { return Parser::make_KEYWORD         (yytext, loc);  }
{NUMERAL}           { return Parser::make_NUMERAL         (yytext, loc);  }
{SYMBOL}            { return Parser::make_SYMBOL          (yytext, loc);  }

\"                  { quoted_value.str(std::string()); yy_push_state(START_STRING); }

<START_STRING>{
  \\\"              { quoted_value << '"';      }
  \\\\              { quoted_value << '\\';     }
  [^\"\n]           { quoted_value << yytext;   }
  \n                { quoted_value << '\n';     }
  \"                { yy_pop_state(); return Parser::make_STRING (quoted_value.str(), loc); }
}

\/                  { quoted_value.str(std::string()); yy_push_state(START_REGEX); }

<START_REGEX>{
  \\\/              { quoted_value << '/';      }
  \\\\              { quoted_value << '\\';     }
  [^\/\n]           { quoted_value << yytext;   }
  \n                { quoted_value << '\n';     }
  \/                { yy_pop_state(); return Parser::make_REGEX (quoted_value.str(), loc); }
}

\|                  { quoted_value.str(std::string()); yy_push_state(START_QUOTEDSYMBOL); }

<START_QUOTEDSYMBOL>{
  [^|\\]              { quoted_value << yytext; }
  \|                { yy_pop_state(); return Parser::make_SYMBOL (quoted_value.str(), loc); }
}

.                   { LexerError("invalid character");            }
<<EOF>>             { return Parser::make_END             (loc);  }

%%
